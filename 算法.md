# 并查集

处理一些不交集的 **合并** 及 **查询** 问题。

```c++
//初始化
void makeSet(int size) {
	for (int i = 0; i < size; i++) fa[i] = i;  // i就在它本身的集合里
}
//查找
int fa[MAXN];  // 记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己
int find(int x) {
	if (x != fa[x])  // x不是自身的父亲，即x不是该集合的代表
		fa[x] = find(fa[x]);  // 查找x的祖先直到找到代表,于是顺手路径压缩
	return fa[x];
}
//合并
vector<int> size(N, 1);  // 记录并初始化子树的大小为 1
void unionSet(int x, int y) {
	int xx = find(x), yy = find(y);
	if (xx == yy) return;
	if (size[xx] > size[yy])  // 保证小的合到大的里
		swap(xx, yy);
	fa[xx] = yy;
	size[yy] += size[xx];
}
```

# 堆

孩子节点值大于（小于）父亲节点的完全二叉树。

+ 插入，末尾加数，向上调整，与父亲节点比较。
+ 弹出堆顶元素，将末尾的数放在堆顶，向下调整，取孩子较大（较小）的进行比较。

```c++
void up(int x) {
	while (x > 1 && h[x] > h[x / 2]) {
		swap(h[x], h[x / 2]);//不进行交换操作，过程相当于查找其对应的位置，不过需要在循环外增加一次赋值。
		x /= 2;
	}
}
void down(int x) {
	while (x * 2 <= n) {
		t = x * 2;
		if (t + 1 <= n && h[t + 1] > h[t]) t++;
		if (h[t] <= h[x]) break;
		swap(h[x], h[t]);
		x = t;
	}
}
```

# 单调栈、单调队列

求下一个更大元素，将栈顶的元素与当前元素相比，如果当前大，则表示前面元素的下一个更大元素为当前值。

```c++
while(stack.empty()&&a[stack.top()]<a[i]){//单减
    int id=stack.top(); 
    stack.pop();
    ans[id]=a[i];
}
stack.push(i);
```

求一个窗口内的最小值，使用单调增队列，存储可能的最小值，左边界达到队列头时，从头删除，最小值为队列头作为下标对应的值。

```c++
while(!deque.empty()&&a[deque.back()]>a[i])deque.pop_back();
deque.push_back(i);
if(deque.front()==i-K)deque.pop_front();
```

# 字符串

## 字典树Trie

<img src="img/image-20210326100324879.png" alt="image-20210326100324879" style="zoom:50%;" />

字典树用**边来代表字母**，而从根结点到树上某一结点的路径就代表了一个字符串。exist[p]表示以p结尾的字符串存在。

```c++
//如图所示依次添加 "aa","ba","aba","caaa","cab","cba","cc";exist[3,5,7,11,12,14,15]=1;分别对应各字符串
struct trie {
	int nex[100000][26], cnt;  //cnt 一排长度为26的新空间，
	bool exist[100000];  // 该结点结尾的字符串是否存在

	void insert(char* s, int l) {  // 插入字符串
		int p = 0;
		for (int i = 0; i < l; i++) {
			int c = s[i] - 'a';
			if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
			p = nex[p][c];
		}
		exist[p] = 1;
	}
	bool find(char* s, int l) {  // 查找字符串
		int p = 0;
		for (int i = 0; i < l; i++) {
			int c = s[i] - 'a';
			if (!nex[p][c]) return 0;//提前截至了，说明没有匹配的字符串
			p = nex[p][c];
		}
		return exist[p];
	}
};
```



# 范围查询操作

操作：对于一个数组，长度n，1）求某个区间的和，2）更新某个值。

思路：将区间分块，记录每个子块的和，某个区间的和等于**该区间包括的子块之和**，更新某个值，只需要**更新相关块的和**。

## ST表

最大最小查询

+ 求区间的最大\最小值。$f(i,j)$表示区间$[i,i+2^j-1]$的最大值，状态转移方程：$f(i,j)=max(f(i,j-1),f(i+2^{j-1},j-1))$。

  则给定$[l,r]$，分为$f[l,l+2^s-1],f[r-2^s+1,r]$两个区间，其中$s=log_2(r-l+1)$。

![image-20210326005300229](img/image-20210326005300229.png)

```c++
const int logn = 21;
const int maxn = 2000001;
int f[maxn][logn + 1], Logn[maxn + 1];
void pre() { //求出每个数i对应的log2(i)值
	Logn[1] = 0;
	Logn[2] = 1;
	for (int i = 3; i < maxn; i++) {
		Logn[i] = Logn[i / 2] + 1;
	}
}
for (int i = 1; i <= n; i++) f[i][0] = read();

for (int j = 1; j <= logn; j++){//逐层求出每个位置长度为2^j区域的最大值
    for (int i = 1; i + (1 << j) - 1 <= n; i++)
      f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
}
```



## 树状数组（Binary Indexed Tree）

用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是更多的小节点。大节点是为2的整数幂次方的位置。

+ 树状数组：长度n，如下图所示，$2^i$的位置存储之前所有的和。**查询前缀和，单点增加**。

![preview](img/v2-5bd54a864cf8aaaaef5faa6dccaa5d2d_r.jpg)

```c++
// 算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数
int lowbit(int x) {  
  return x & -x;  //x的负数为每位取反+1，所以x&-1得x最右端1的位置
}
// 求前缀和，a[1]……a[x]的和 如[1,7]区间：可以划分成[1,4], [5,6]和[7,7]
int getsum(int x) {  
  int ans = 0;
  while (x >= 1) { 
    ans = ans + c[x];
    x = x - lowbit(x);  //将最右端的1变为0，下一区间
  }
  return ans;
}
//对下标为x的值增加k
void add(int x, int k) {
  while (x <= n) {  // 不能越界
    c[x] = c[x] + k;
    x = x + lowbit(x);  //更新父亲节点，
  }
}
```

+ 求一个数组的逆序对数，将数组排序，得到每个元素的排名，将问题转化为**排名的前序和**。后面有多少元素比它小。
  1. 从后往前，依次求**元素排名位置的前序和**，表示当前数加进去，对于后面比它较小的元素而言，所产生的新增逆序对数。
  2. 更新树，元素排名位置和他上级加一，表示更新位置i（排名）的前面新增了1比当前排名低（值小）的数。

```c++
int cnt = 0;
for (int i = A.size() - 1; i >= 0; --i) {
    cnt += query(A[i]);
    update(A[i], 1);//排名为A[i]位置上的数个数加一
}
```

## 线段树（Segment Tree）

申请长度为4n的额外数组，构成完全二叉树，叶节点存储当个值，**根节点储存整个区间的和，子节点各存储半个的范围和**。

+ 叶子节点n个，中间节点x；树的边数e=2x，节点数v=e+1；x+n=2x+1；所以**中间节点个数为n-1**。
+ 坐标的最大值，叶节点可能会在最高一层的后几个位置，$1+2+4+\dots+2^{[log_2n]}=2^{[log_2n]+1}<4*n$。

![sum-segment-tree](img/sum-segment-tree.png)

```c++
//根节点为下标为1
class SegmentTree {
    vector<int> rangeSum;
public:
    SegmentTree(int n): rangeSum(n * 4){ }
    //求个区间的和，树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
    void build(vector<int>& arr, int v, int tl, int tr)
    {
        if (tl == tr) { //当前区间只有一个元素
            rangeSum[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v * 2, tl, tm);
            build(arr, v * 2 + 1, tm + 1, tr);
            rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
        }
    }
    //查询区间[l,r]的和
    int query(int v, int tl, int tr, int l, int r)
    {
        if (l > r)
            return 0;
        if (l == tl && r == tr) { //当前子区间为需要查询的区间
            return rangeSum[v];
        }
        int tm = (tl + tr) / 2;
        int leftRange = query(v * 2, tl, tm, l, min(r, tm));
        int rightRange = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
        return leftRange + rightRange;
    }
    //更新值
    void update(int v, int tl, int tr, int pos, int new_val)
    {
        if (tl == tr) {
            rangeSum[v] = new_val;
        } else {
            int tm = (tl + tr) / 2;
            if (pos <= tm) //修改值在左子区间
                update(v * 2, tl, tm, pos, new_val);
            else
                update(v * 2 + 1, tm + 1, tr, pos, new_val);
            rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
        }
    }
};
```

+ **Range updates (Lazy Propagation)**，一次修改一个区间里的所有值，**记录范围的操作，要查询时，再将操作下沉到具体位置上**。如1）求区间最大值，2）区间每个值加val。

```c++
class SegmentTree {
    vector<int> rangeMax, lazy;

  public:
    SegmentTree(int n) : rangeMax(n * 4), lazy(n * 4) {}
    void push(int v) {
        rangeMax[v * 2] += lazy[v];
        rangeMax[v * 2 + 1] += lazy[v];
        lazy[v * 2] += lazy[v]; //操作下沉到子区间
        lazy[v * 2 + 1] += lazy[v];
        lazy[v] = 0;
    }
    //树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
    void build(vector<int> &arr, int v, int tl, int tr) {
        if (tl == tr) { //当前区间只有一个元素
            rangeMax[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v * 2, tl, tm);
            build(arr, v * 2 + 1, tm + 1, tr);
            rangeMax[v] = fmax(rangeMax[v * 2], rangeMax[v * 2 + 1]);
        }
    }
    //更新区间[l,r]里所有元素值
    void update(int v, int tl, int tr, int l, int r, int addend) {
        if (l > r)//区间外不更新
            return;
        if (l == tl && tr == r) { //当前区间的元素都要操作
            rangeMax[v] += addend;
            lazy[v] += addend;
        } else {
            push(v); //该区间大于操作区间[l,r]，下沉之前累积的操作，
            int tm = (tl + tr) / 2;
            update(v * 2, tl, tm, l, min(r, tm), addend);
            update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
            rangeMax[v] = max(rangeMax[v * 2], rangeMax[v * 2 + 1]);
        }
    }
    //查询区间[l,r]的大值
    int query(int v, int tl, int tr, int l, int r) {
        if (l > r) 
            return INT_MIN;
        if (l <= tl && tr <= r)
            return rangeMax[v];
        push(v); //
        int tm = (tl + tr) / 2;
        int leftMax = query(v * 2, tl, tm, l, min(r, tm));
        int rightMax = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
        return fmax(leftMax, rightMax);
    }
};
```

## 后缀数组

  

