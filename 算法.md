# 范围查询问题

操作：对于一个数组，长度n，1）求某个区间的和，2）更新某个值。

思路：将区间分块，记录每个子块的和，某个区间的和等于**该区间包括的子块之和**，更新某个值，只需要**更新相关块的和**。

## 树状数组（Binary Indexed Tree）

用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是更多的小节点。大节点是为2的整数幂次方的位置。

+ 树状数组：长度n，如下图所示，$2^i$的位置存储之前所有的和。**查询前缀和，单点增加**。

![preview](img/v2-5bd54a864cf8aaaaef5faa6dccaa5d2d_r.jpg)

```c++
// 算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数
int lowbit(int x) {  
  return x & -x;  //x的负数为每位取反+1，所以x&-1得x最右端1的位置
}
// 求前缀和，a[1]……a[x]的和 如[1,7]区间：可以划分成[1,4], [5,6]和[7,7]
int getsum(int x) {  
  int ans = 0;
  while (x >= 1) { 
    ans = ans + c[x];
    x = x - lowbit(x);  //将最右端的1变为0，
  }
  return ans;
}
//对下标为x的值增加k
void add(int x, int k) {
  while (x <= n) {  // 不能越界
    c[x] = c[x] + k;
    x = x + lowbit(x);  //更新父亲节点，
  }
}
```

+ 求一个数组的逆序对数，将数组排序，得到每个元素的排名，将问题转化为**排名的前序和**。后面有多少元素比它小。
  1. 从后往前，依次求**元素排名位置的前序和**，表示当前数加进去，对于后面比它较小的元素而言，所产生的新增逆序对数。
  2. 更新树，元素排名位置和他上级加一，表示更新位置i（排名）的前面新增了1比当前排名低（值小）的数。

```c++
int cnt = 0;
for (int i = A.size() - 1; i >= 0; --i) {
    cnt += query(A[i]);
    update(A[i], 1);
}
```

## 线段树（Segment Tree）

申请长度为4n的额外数组，构成完全二叉树，叶节点存储当个值，**根节点储存整个区间的和，子节点各存储半个的范围和**。

+ 叶子节点n个，中间节点x；树的边数e=2x，节点数v=e+1；x+n=2x+1；所以**中间节点个数为n-1**。
+ 坐标的最大值，叶节点可能会在最高一层的后几个位置，$1+2+4+\dots+2^{[log_2n]}=2^{[log_2n]+1}<4*n$。

![sum-segment-tree](img/sum-segment-tree.png)

```c++
//根节点为下标为1
class SegmentTree {
    vector<int> rangeSum;
public:
    SegmentTree(int n): rangeSum(n * 4){ }
    //求个区间的和，树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
    void build(vector<int>& arr, int v, int tl, int tr)
    {
        if (tl == tr) { //当前区间只有一个元素
            rangeSum[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v * 2, tl, tm);
            build(arr, v * 2 + 1, tm + 1, tr);
            rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
        }
    }
    //查询区间[l,r]的和
    int query(int v, int tl, int tr, int l, int r)
    {
        if (l > r)
            return 0;
        if (l == tl && r == tr) { //当前子区间为需要查询的区间
            return rangeSum[v];
        }
        int tm = (tl + tr) / 2;
        int leftRange = query(v * 2, tl, tm, l, min(r, tm));
        int rightRange = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
        return leftRange + rightRange;
    }
    //更新值
    void update(int v, int tl, int tr, int pos, int new_val)
    {
        if (tl == tr) {
            rangeSum[v] = new_val;
        } else {
            int tm = (tl + tr) / 2;
            if (pos <= tm) //修改值在左子区间
                update(v * 2, tl, tm, pos, new_val);
            else
                update(v * 2 + 1, tm + 1, tr, pos, new_val);
            rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
        }
    }
};
```

+ **Range updates (Lazy Propagation)**，一次修改一个区间里的所有值，**记录范围的操作，要查询时，再将操作下沉到具体位置上**。如1）求区间最大值，2）区间每个值加val。

```c++
class SegmentTree {
    vector<int> rangeMax, lazy;

  public:
    SegmentTree(int n) : rangeMax(n * 4), lazy(n * 4) {}
    void push(int v) {
        rangeMax[v * 2] += lazy[v];
        rangeMax[v * 2 + 1] += lazy[v];
        lazy[v * 2] += lazy[v]; //操作下沉到子区间
        lazy[v * 2 + 1] += lazy[v];
        lazy[v] = 0;
    }
    //树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
    void build(vector<int> &arr, int v, int tl, int tr) {
        if (tl == tr) { //当前区间只有一个元素
            rangeMax[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v * 2, tl, tm);
            build(arr, v * 2 + 1, tm + 1, tr);
            rangeMax[v] = fmax(rangeMax[v * 2], rangeMax[v * 2 + 1]);
        }
    }
    //更新区间[l,r]里所有元素值
    void update(int v, int tl, int tr, int l, int r, int addend) {
        if (l > r)//区间外不更新
            return;
        if (l == tl && tr == r) { //当前区间的元素都要操作
            rangeMax[v] += addend;
            lazy[v] += addend;
        } else {
            push(v); //该区间大于操作区间[l,r]，下沉之前累积的操作，
            int tm = (tl + tr) / 2;
            update(v * 2, tl, tm, l, min(r, tm), addend);
            update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
            rangeMax[v] = max(rangeMax[v * 2], rangeMax[v * 2 + 1]);
        }
    }
    //查询区间[l,r]的大值
    int query(int v, int tl, int tr, int l, int r) {
        if (l > r) 
            return INT_MIN;
        if (l <= tl && tr <= r)
            return rangeMax[v];
        push(v); //
        int tm = (tl + tr) / 2;
        int leftMax = query(v * 2, tl, tm, l, min(r, tm));
        int rightMax = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
        return fmax(leftMax, rightMax);
    }
};
```

## 后缀数组

  

