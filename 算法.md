## 树状数组（Binary Indexed Tree）和线段树（Segment Tree）

操作：对于一个数组，长度n，1）求某个区间的和，2）更新某个值。

思路：将区间分块，记录每个子块的和，某个区间的和等于**该区间包括的子块之和**，更新某个值，只需要**更新相关块的和**。

+ 树状数组：长度n，如下图所示

![preview](https://pic2.zhimg.com/v2-5bd54a864cf8aaaaef5faa6dccaa5d2d_r.jpg)

```c++

```

+ 线段树：
  + 叶子节点n个，中间节点x；树的边数e=2x，节点数v=e+1；x+n=2x+1；所以中间节点个数为n-1。
  + 坐标的最大值，叶节点可能会在最高一层的后几个位置，$1+2+4+\dots+2^{[log_2n]}=2^{[log_2n]+1}<4*n$。
  
  ![sum-segment-tree](img/sum-segment-tree.png)
  
  ```c++
  //根节点为下标为1
  class SegmentTree {
      vector<int> rangeSum;
  public:
      SegmentTree(int n): rangeSum(n * 4){ }
      //求个区间的和，树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
      void build(vector<int>& arr, int v, int tl, int tr)
      {
          if (tl == tr) { //当前区间只有一个元素
              rangeSum[v] = arr[tl];
          } else {
              int tm = (tl + tr) / 2;
              build(arr, v * 2, tl, tm);
              build(arr, v * 2 + 1, tm + 1, tr);
              rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
          }
      }
      //查询区间[l,r]的和
      int query(int v, int tl, int tr, int l, int r)
      {
          if (l > r)
              return 0;
          if (l == tl && r == tr) { //当前子区间为需要查询的区间
              return rangeSum[v];
          }
          int tm = (tl + tr) / 2;
          int leftRange = query(v * 2, tl, tm, l, min(r, tm));
          int rightRange = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
          return leftRange + rightRange;
      }
      //更新值
      void update(int v, int tl, int tr, int pos, int new_val)
      {
          if (tl == tr) {
              rangeSum[v] = new_val;
          } else {
              int tm = (tl + tr) / 2;
              if (pos <= tm) //修改值在左子区间
                  update(v * 2, tl, tm, pos, new_val);
              else
                  update(v * 2 + 1, tm + 1, tr, pos, new_val);
              rangeSum[v] = rangeSum[v * 2] + rangeSum[v * 2 + 1];
          }
      }
  };
  ```
  
  + **Range updates (Lazy Propagation)**，一次修改一个区间里的所有值，**记录范围的操作，要查询时，再将操作下沉到具体位置上**。如1）求区间最大值，2）区间每个值加val。
  
  ```c++
  class SegmentTree {
      vector<int> rangeMax, lazy;
  
    public:
      SegmentTree(int n) : rangeMax(n * 4), lazy(n * 4) {}
      void push(int v) {
          rangeMax[v * 2] += lazy[v];
          rangeMax[v * 2 + 1] += lazy[v];
          lazy[v * 2] += lazy[v]; //操作下沉到子区间
          lazy[v * 2 + 1] += lazy[v];
          lazy[v] = 0;
      }
      //树的当前节点v覆盖数组arr的左边界tl，和右边界tr。
      void build(vector<int> &arr, int v, int tl, int tr) {
          if (tl == tr) { //当前区间只有一个元素
              rangeMax[v] = arr[tl];
          } else {
              int tm = (tl + tr) / 2;
              build(arr, v * 2, tl, tm);
              build(arr, v * 2 + 1, tm + 1, tr);
              rangeMax[v] = fmax(rangeMax[v * 2], rangeMax[v * 2 + 1]);
          }
      }
      //更新区间[l,r]里所有元素值
      void update(int v, int tl, int tr, int l, int r, int addend) {
          if (l > r)//区间外不更新
              return;
          if (l == tl && tr == r) { //当前区间的元素都要操作
              rangeMax[v] += addend;
              lazy[v] += addend;
          } else {
              push(v); //该区间大于操作区间[l,r]，下沉之前累积的操作，
              int tm = (tl + tr) / 2;
              update(v * 2, tl, tm, l, min(r, tm), addend);
              update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
              rangeMax[v] = max(rangeMax[v * 2], rangeMax[v * 2 + 1]);
          }
      }
      //查询区间[l,r]的大值
      int query(int v, int tl, int tr, int l, int r) {
          if (l > r) 
              return INT_MIN;
          if (l <= tl && tr <= r)
              return rangeMax[v];
          push(v); //
          int tm = (tl + tr) / 2;
          int leftMax = query(v * 2, tl, tm, l, min(r, tm));
          int rightMax = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
          return fmax(leftMax, rightMax);
      }
  };
  ```
  
## 后缀数组

  

